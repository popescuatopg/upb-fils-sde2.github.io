---
sidebar_position: 2
---

# TP 01 - Rust pour les d√©butants

## Assignment
:::tip
Vous devez **accepter** l'assignment d'ici est travailler avec ce **repository**: Lab0
:::
## Resources
 1. The Rust Programming Language, Chapitre 1, 2, 3 et 5 [en](https://doc.rust-lang.org/book/#the-rust-programming-language) et [fr](https://jimskapt.github.io/rust-book-fr/)

 2. Tour of Rust [ici](https://tourofrust.com/)

## Concepts basiques de langages de programmation pour Rust
### Standard library

La biblioth√®que standard est divis√©e en trois niveaux¬†:

| Niveau | Description | Besoin |
|-------|:------------|:------|
| [`core`](https://doc.rust-lang.org/core/index.html) | Fournit les √©l√©ments de langage requis dont Rust a besoin pour la compilation, comme les traits `Display` et `Debug`. Les donn√©es ne peuvent √™tre que des √©l√©ments globaux (stock√©s dans *.data*) ou sur la *pile*. | Hardware |
| [`alloc`](https://doc.rust-lang.org/alloc/index.html) | Fournit tout, depuis le niveau `core` ainsi que les structures de donn√©es allou√©es *heap* comme `Box` et `Vec`. Le d√©veloppeur doit fournir une m√©moire allou√©e, comme [embedded_alloc](https://docs.rs/embedded-alloc/latest/embedded_alloc/). | Memory Allocator |
| [`std`](https://doc.rust-lang.org/std/index.html) | Fournit tout, depuis le niveau `alloc`, ainsi que de nombreuses fonctionnalit√©s qui d√©pendent de la plate-forme, y compris les threads et les E/S. Il s'agit du niveau par d√©faut pour les applications Windows, Linux, macOS et syst√®mes d'exploitation similaires. | Operating System |


Par d√©faut, Rust a un ensemble d'√©l√©ments d√©finis dans la biblioth√®que standard qu'il introduit dans le cadre d'application de chaque programme. Cet ensemble s'appelle le pr√©lude, et vous pouvez voir tout ce qu'il contient dans la documentation standard de la [biblioth√®que](https://doc.rust-lang.org/std/prelude/index.html).

Si un type que vous voulez utiliser n'est pas dans le pr√©lude, vous devez mettre ce type dans la port√©e **explicitement** avec une instruction use. L'utilisation de la biblioth√®que std :: io vous offre un certain nombre de fonctionnalit√©s utiles, notamment la possibilit√© d'accepter les entr√©es de l'utilisateur.
```rust
use std::io;
```

### La fonction `main`
La fonction `main` est le entry point de notre programme.

```rust
fn main() {
    println!("Hello, world!");
}
```

On utilise `println!()` pour imprimer des messages sur l'ecran.

Pour ins√©rer un placeholder dans le `println!` m√©thode, utilisez une *paire d'accolades* `{}`. Nous fournissons le nom ou l'expression de la variable pour **remplacer** le placeholder fourni en dehors de la cha√Æne.

```rust
fn main() {
 
    let name = "Mary";
    let age = 26;
    let color = "blue";
 
    println!("Hello, {}. You are {} years old", name, age);
    println!("What is your favourite color? Is it {color}?");
}
```

### Variables et mutabilit√©
On utilise le mot-cl√© `let` pour cr√©er un variable.

```rust
let a = 5;
```

Par d√©faut, en Rust, les variables sont **immuables**, √ßa veut dire, une fois qu'une valeur est li√©e √† un nom, vous **ne pouvez pas** modifier cette valeur.

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
Dans ce cas, on va obtenir un erreur de compilation parce qu‚Äôon essaye de modifier la valeur de `x` de 5 √† 6, mais `x` est immuable, donc on ne peut pas faire cette modification.

Bien que les variables soient immuables par d√©faut, vous pouvez les rendre **modifiables** en ajoutant `mut` devant le nom de la variable. L'ajout de mut transmet √©galement l'intention aux futurs lecteurs du code en indiquant que d'autres parties du code modifieront la valeur de cette variable.
```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {x}");
    x = 6;
    println!("The value of x is: {x}");
}
```
Maintenant, la valeur de `x` peut devenir `6`.

### Constantes

Comme les variables immuables, les constantes sont des valeurs qui sont li√©es √† un nom et **ne sont pas autoris√©es √† changer**, mais il existe quelques diff√©rences entre les constantes et les variables.

Tout d'abord, vous n'√™tes pas autoris√© √† utiliser `mut` avec des constantes. Les constantes ne sont pas seulement immuables par d√©faut, elles sont toujours immuables. Vous d√©clarez des constantes en utilisant le mot cl√© *const* au lieu du mot cl√© *let*.

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
:::tip
Pour comprendre mieux, lire le **chapitre 3** qui se trouve dans la **documentation** au d√©but du TP!
:::
### Types des donn√©es
#### Types scalaire
Un type scalaire repr√©sente une valeur unique. Rust a quatre types scalaires principaux : entiers, nombres √† virgule flottante, bool√©ens et caract√®res.

**Integer** ‚Üí Chaque variante peut √™tre sign√©e ou non sign√©e et a une taille explicite.

```rust
let x: i8 = -2;
let y: u16 = 25;
```

| Length              | Signed | Unsigned | Java Equivalent |
| :----------------: | :------: | :----: | :----: |
| 8-bit |   `i8`   | `u8` | `byte`/ `Byte`[^java_unsigned] |
| 16-bit |   `i16`   | `u16` | `short` / `Short`[^java_unsigned] |
| 32-bit |   `i32`   | `u32` | `int` / `Integer`[^java_unsigned] |
| 64-bit |   `i64`   | `u64` | `long` / `Long`[^java_unsigned] |
| 128-bit |   `i128`   | `u128` | N/A |
| arch |   `isize`   | `usize` | N/A |

**Virgule flottante** ‚Üí Les types √† virgule flottante de Rust sont f32 et f64, qui ont respectivement une taille de 32 bits et 64 bits. Le type par d√©faut est **f64** car sur les processeurs modernes, c'est √† peu pr√®s la m√™me vitesse que f32 mais il est capable de plus de pr√©cision. Tous les types √† virgule flottante sont **sign√©s**.
| Length              | Floating point | Java Equivalent|
| :----------------: | :------: | :----: | 
| 32-bit | `f32` | `float` |
| 64-bit | `f64` | `double` |
```rust
fn main() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
```

**Boolean** ‚Üí Les bool√©ens ont une taille d'un octet. Le type bool√©en dans Rust est sp√©cifi√© √† l'aide de *bool*.

```rust
let t = true;
let f: bool = false; // with explicit type annotation
```

**Caractere** ‚Üí Le type char de Rust est le type alphab√©tique le plus primitif du langage.

```rust
let c = 'z';
let z: char = '‚Ñ§'; // with explicit type annotation
let heart_eyed_cat = 'üòª';
```

#### Types compos√©s
**Tuple** ‚Üí Un tuple est une mani√®re g√©n√©rale de regrouper un certain nombre de valeurs avec une vari√©t√© de types en un seul type compos√©. Les tuples ont une longueur **fixe** : une fois d√©clar√©s, leur taille ne peut pas augmenter ou diminuer.

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

**Array** ‚Üí Contrairement √† un tuple, chaque √©l√©ment d'un tableau doit avoir le **m√™me type**. Contrairement aux tableaux de certains autres langages, les tableaux de Rust ont une longueur **fixe**.

```rust
let a = [1, 2, 3, 4, 5];
```
:::tip
Pour comprendre mieux, lire le **chapitre 3** qui se trouve dans la documentation au d√©but du TP!
:::

### Fonctions

Nous d√©finissons une fonction dans Rust en entrant *fn* suivi d'un nom de fonction et d'un ensemble de parenth√®ses. Les accolades indiquent au compilateur o√π commence et se termine le corps de la fonction.

```rust
fn main() {
    println!("Hello, world!");
 
    another_function();
}
 
fn another_function() {
    println!("Another function.");
}

```

#### Parametres

Nous pouvons d√©finir des fonctions avec des param√®tres, qui sont des variables sp√©ciales qui font partie de la signature d'une fonction. Lorsqu'une fonction a des param√®tres, vous pouvez lui fournir des **valeurs concr√®tes** pour ces param√®tres.
```rust
fn main() {
    another_function(5);
}
 
fn another_function(x: i32) {
    println!("The value of x is: {x}");
}

```
:::tip
Dans les signatures de fonctions, vous devez d√©clarer le **type** de chaque param√®tre!
:::
#### D√©clarations vs. expressions

Les corps de fonction sont constitu√©s d'une s√©rie d'instructions se terminant √©ventuellement par une expression.

Les **d√©clarations** sont des instructions qui effectuent une action et ne renvoient pas de valeur.

Les **expressions** √©valuent une valeur r√©sultante.

:::tip
Pour comprendre mieux, lire le **chapitre 3** qui se trouve dans la **documentation** au d√©but du TP! 
:::

#### Fonctions avec valeurs de retour

Les fonctions peuvent renvoyer des valeurs au code qui les appelle. Nous ne nommons pas les valeurs de retour, mais nous devons d√©clarer leur type apr√®s **une fl√®che (->)**. En Rust, la valeur de retour de la fonction est synonyme de la valeur de **l'expression finale** dans le bloc du corps d'une fonction. Vous pouvez revenir plus t√¥t √† partir d'une fonction en utilisant le mot-cl√© *return* et en sp√©cifiant une valeur, mais la plupart des fonctions renvoient implicitement la derni√®re expression.

```rust
fn five() -> i32 {
    5
}
 
fn main() {
    let x = five();
    println!("The value of x is: {x}");// "The value of x is: 5"
}

```
:::tip
Pour comprendre mieux, lire le **chapitre 3** qui se trouve dans la **documentation** au d√©but du TP!
:::
### Flux de contr√¥le

#### if-else

Toutes les expressions `if` commencent par le mot-cl√© `if`, suivi d'une condition. Facultativement, nous pouvons √©galement inclure une expression `else`.

```rust
fn main() {
    let number = 3;
 
    if number < 5 {
        println!("condition was true");
    } else {
        println!("condition was false");
    }
}
```

Vous pouvez utiliser plusieurs conditions en combinant `if` et `else` dans une expression `else if`:

```rust
fn main() {
    let number = 6;
 
    if number % 4 == 0 {
        println!("number is divisible by 4");
    } else if number % 3 == 0 {
        println!("number is divisible by 3");
    } else if number % 2 == 0 {
        println!("number is divisible by 2");
    } else {
        println!("number is not divisible by 4, 3, or 2");
    }
}
```
Parce que `if` est une expression, nous pouvons l'utiliser sur **le c√¥t√© droit** d'une instruction `let` pour affecter le r√©sultat √† une variable.

```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };
 
    println!("The value of number is: {number}");//"The value of the number is 5"
}
```

#### Loop

Le mot-cl√© `loop` indique √† Rust d'ex√©cuter un bloc de code encore et encore pour toujours ou jusqu'√† ce que vous lui disiez **explicitement** de s'arr√™ter.

```rust
fn main() {
    loop {
        println!("again!");
    }
}
```
L'une des utilisations d'une boucle est de *r√©essayer* une op√©ration dont vous savez qu'elle pourrait √©chouer, comme v√©rifier si un thread a termin√© son travail. Vous devrez peut-√™tre √©galement transmettre le r√©sultat de cette op√©ration hors de la boucle au reste de votre code. Pour ce faire, vous pouvez ajouter la valeur que vous souhaitez renvoyer apr√®s l'expression break que vous utilisez pour arr√™ter la boucle ; cette valeur sera renvoy√©e hors de la boucle afin que vous puissiez l'utiliser:

```rust
fn main() {
    let mut counter = 0;
 
    let result = loop {
        counter += 1;
 
        if counter == 10 {
            break counter * 2;
        }
    };
 
    println!("The result is {result}");
}
```

#### While
```rust
fn main() {
    let mut number = 3;
 
    while number != 0 {
        println!("{number}!");
 
        number -= 1;
    }
 
    println!("LIFTOFF!!!");
}
```
#### For
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];
 
    for element in a {
        println!("the value is: {element}");
    }
}
```
:::tip
Pour comprendre mieux, lire le **chapitre 3** qui se trouve dans la documentation au d√©but du TP!
:::

#### Structures
Les **structures** sont similaires aux tuples, en ce sens qu'elles contiennent les deux plusieurs valeurs li√©es. Comme les tuples, les morceaux d'une structure peuvent √™tre de diff√©rents types. Contrairement aux tuples, dans une structure, vous **nommerez** chaque √©l√©ment de donn√©es afin que la signification des valeurs soit claire.

Pour **d√©finir** une structure, nous entrons le mot-cl√© `struct` et nommons la structure enti√®re. Le nom d'une structure doit d√©crire la signification des √©l√©ments de donn√©es regroup√©s. Ensuite, entre accolades, nous d√©finissons les noms et les types des donn√©es, que nous appelons **champs**.

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```
Pour utiliser une structure apr√®s l'avoir d√©finie, nous cr√©ons une **instance** de cette structure en sp√©cifiant des valeurs concr√®tes pour chacun des champs. Nous cr√©ons une instance en indiquant le **nom** de la structure, puis ajoutons des accolades contenant des **paires cl√© : valeur**, o√π les cl√©s sont les noms des champs et les valeurs sont les donn√©es que nous voulons stocker dans ces champs.

```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
}
```

Pour acceder a un certain membre du struct on utilise cette syntaxe:

```rust
fn main() {
    let mut user1 = User {
        active: true,
        username: String::from("someusername123"),
        email: String::from("someone@example.com"),
        sign_in_count: 1,
    };
 
    user1.email = String::from("anotheremail@example.com");
}
```
:::tip
Notez que l'instance enti√®re doit √™tre **modifiable** ; Rust **ne nous permet** pas de marquer uniquement certains champs comme mutables!
:::

Comme pour toute expression, nous pouvons construire une nouvelle instance de la structure en tant que derni√®re expression dans le corps de la fonction pour renvoyer implicitement cette nouvelle instance.

```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username: username,
        email: email,
        sign_in_count: 1,
    }
}
```

#### Tuple structs
Rust prend √©galement en charge les structures qui ressemblent aux tuples, appel√©es **tuple structs**. Les structures de tuple ont la signification suppl√©mentaire fournie par le nom de la structure mais n'ont pas de noms associ√©s √† leurs champs ; au lieu de cela, ils ont juste les types des champs. Les structures de tuple sont utiles lorsque vous souhaitez donner un nom √† l'ensemble du tuple et lui donner un type diff√©rent des autres tuples, et lorsque nommer chaque champ comme dans une structure r√©guli√®re serait verbeux ou redondant.

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
 
fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```
:::tip 
Pour comprendre mieux, lire le **chapitre 5** qui se trouve dans la **documentation** au d√©but du TP!
:::

### Enums
Les √©num√©rations, √©galement appel√©es `enum`, vous permettent de d√©finir un type en √©num√©rant ses variantes possibles.
Comment d√©finir une √©num√©ration¬†:

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

### String

Rust n'a qu'un seul type de cha√Æne dans le langage principal, qui est la tranche de cha√Æne `str` qui est g√©n√©ralement vue sous sa forme emprunt√©e `&str`.

Le type `String`, qui est fourni par la biblioth√®que standard Rust plut√¥t que cod√© dans le langage principal, est un type de cha√Æne cod√© en UTF-8 √©volutif, mutable et d√©tenu.

#### Cr√©er une nouvelle String
```rust
    let mut s = String::new();
```
Cette ligne cr√©e une nouvelle cha√Æne vide appel√©e `s`, dans laquelle nous pouvons ensuite charger des donn√©es.

Nous pouvons utiliser la fonction `String::from` ou la fonction `to_string` pour cr√©er une cha√Æne √† partir d'une cha√Æne litt√©rale¬†:

```rust
    let s = String::from("initial contents");
```
```rust
let data = "initial contents";
 
    let s = data.to_string();
 
    // the method also works on a literal directly:
    let s = "initial contents".to_string();
```

#### Ajouter des donn√©es √† une string
Nous pouvons d√©velopper une cha√Æne en utilisant la m√©thode `push_str` pour ajouter une tranche de cha√Æne.

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

**La m√©thode push** prend **un seul caract√®re** comme param√®tre et l'ajoute √† la cha√Æne.

```rust
    let mut s = String::from("lo");
    s.push('l');
```

#### M√©thodes d'it√©ration sur les Strings
La meilleure fa√ßon d‚Äôop√©rer sur des morceaux de cha√Ænes est d‚Äôindiquer explicitement si vous voulez des caract√®res ou des octets. Pour les valeurs scalaires Unicode individuelles, utilisez la m√©thode `chars`.
```rust
for c in "–ó–¥".chars() {
    println!("{c}");
}
```

#### Ex√©cuter le programme
On doit acceder a la directeur ou le fichier main.rs se trouve et executee la comande:
```bash
cargo run
```

### Exercises
:::tip
Avant d'aborder les exercices, jetez un ≈ìil et parcourez les chapitres [1](https://tourofrust.com/chapter_1_en.html), [2](https://tourofrust.com/chapter_2_en.html) et [3](https://tourofrust.com/chapter_3_en.html) des tutoriels [Tour of Rust](https://tourofrust.com/).
:::
1. √âcrivez un programme qui imprime votre nom.
2. D√©finissez deux variables et attribuez-leur une valeur num√©rique. Affiche la valeur maximale entre les deux sans utiliser de variable temporaire.
3. √âcrivez une fonction qui v√©rifie si un nombre est divisible par n.
4. D√©finissez un tableau de nombres et √©crivez le code pour en afficher la valeur maximale.
5. D√©finissez une structure appel√©e Ordinateur qui d√©finit la marque, le nom du processeur et la taille de la m√©moire d'un ordinateur.
    a. Ecrivez une fonction associ√©e (statique) appel√©e new qui cr√©e une instance de la structure.
    b. √âcrivez une m√©thode appel√©e display qui imprime toutes les informations.
6. D√©finissez un tableau avec des √©l√©ments de type Ordinateur. √âcrivez un programme qui affiche un menu avec les options suivantes: a. imprimer tous les ordinateurs, b. imprimer l'ordinateur avec la plus grande quantit√© de m√©moire. Lisez les touches du clavier et ex√©cutez l'option s√©lectionn√©e jusqu'√† ce que vous lisez quelque chose de diff√©rent de a et b.

:::tip
Hint: Hint: utilisez [io::stdin().read_line(&mut buffer)](https://doc.rust-lang.org/std/io/fn.stdin.html) pour lire a partir du clavier.
:::

[^java_unsigned]: √Ä partir de Java 8, les classes `Number` ont des m√©thodes d'assistance, comme `compareUnsigned` et `toUnsigned...` qui permettent l'utilisation et la manipulation de nombres non sign√©s.